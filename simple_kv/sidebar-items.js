window.SIDEBAR_ITEMS = {"constant":[["GZIP",""],["LZ4",""],["ZSTD",""]],"enum":[["KvError",""],["LevelConfig",""],["RotationConfig",""],["StorageConfig",""]],"fn":[["compress",""],["decompress",""],["dispatch",""],["dispatch_stream","从 Request 中得到 Response，目前处理所有 PUBLISH/SUBSCRIBE/UNSUBSCRIBE"],["read_frame","从 stream 中读出一个完整的 frame"],["start_client_with_config","通过配置创建 kv 客户端"],["start_server_with_config","通过配置创建 kv 服务器"]],"mod":[["command_request","Nested message and enum types in `CommandRequest`."],["value","Nested message and enum types in `Value`."]],"struct":[["Broadcaster","用于主题发布和订阅的数据结构"],["ClientConfig",""],["ClientTlsConfig",""],["CommandRequest","来自客户端的命令请求"],["CommandResponse","服务端的命令响应"],["GeneralConfig",""],["Gzip",""],["Hdel","del 相关命令"],["Hexist","存在性判断"],["Hget","get 相关命令"],["Hgetall",""],["Hmdel",""],["Hmexist",""],["Hmget",""],["Hmset",""],["Hset","set 相关命令"],["Kvpair","返回键值对"],["LogConfig",""],["Lz4",""],["MemTable","基于 DashMap 构造 MemTable，实现 Storage Trait"],["PSubscribe","订阅某个模式"],["PUnsubscribe","退订某个模式"],["ProstClientStream","处理 Client socket 的读写"],["ProstServerStream","处理服务端某个 accept 下的 socket 读写"],["ProstStream","处理 KV server prost frame 的 stream"],["Publish","发布数据到某个主题"],["ServerConfig",""],["ServerTlsConfig",""],["Service","Service 数据结构，其作用是将 CommandService 和 Storage 这两个 Trait 联合起来 避免向用户暴露底层细节"],["ServiceInner","ServiceInner：Service 内部数据结构，这也是 Rust 的一个惯例，把需要在多线程下 clone 的主体和其内部结构分开，这样代码逻辑更加清晰"],["SledDb",""],["StorageIter","提供 Storage Iterator 来对 iter 进行抽象，这样 trait 的实现者 只需要将它们的 iterator 提供了 StorageIter，然后它们保证 next() 传出的类型实现了 Into 即可"],["StreamResult","创建时获取 subscription id，并使用 Deref/DerefMut 使其使用上和 Stream 一致"],["Subscribe","订阅某个主题"],["TlsClientConnector","存放 TLS Client 并提供方法 connect 来将底层协议转换为 TLS"],["TlsServerAcceptor","存放 TLS ServerConfig 并提供方法 accept 将底层的协议转换成为 TLS"],["Unsubscribe","退订某个主题"],["Value","返回键值"],["YamuxCtrl","控制结构"],["Zstd",""]],"trait":[["CommandService","对 Command 的处理进行抽象"],["Compressor",""],["FrameCoder",""],["Notify","不可变事件通知"],["NotifyMut","可变事件通知"],["Storage","对存储的抽象，定义了外界如何与后端打交道"],["Topic",""],["TopicService",""]],"type":[["AfterSendFunc",""],["BeforeSendFunc",""],["ReceivedFunc",""],["ResponseFunc",""],["StreamingResponse","使用 tokio-stream 的 stream wrapper 来把一个 mpsc::Receiver 转换 成 Receiver Stream，这样就可以不断调用 next 来获得下一个值"]]};